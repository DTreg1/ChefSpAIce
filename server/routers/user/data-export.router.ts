import { Router, Request, Response, NextFunction } from "express";
import { db } from "../../db";
import {
  users,
  userSyncData,
  subscriptions,
  userInventoryItems,
  userSavedRecipes,
  userMealPlans,
  userShoppingItems,
  userCookwareItems,
  userWasteLogs,
  userConsumedLogs,
  userStorageLocations,
  userSyncKV,
  referrals,
  cancellationReasons,
  conversionEvents,
  feedback,
  nutritionCorrections,
  userAppliances,
  authProviders,
  userSessions,
  notifications,
  passwordResetTokens,
} from "@shared/schema";
import { eq } from "drizzle-orm";
import { successResponse } from "../../lib/apiResponse";
import { AppError } from "../../middleware/errorHandler";

const router = Router();

router.get("/", async (req: Request, res: Response, next: NextFunction) => {
  try {
    const userId = req.userId;
    if (!userId) {
      throw AppError.unauthorized("Authentication required", "UNAUTHORIZED");
    }

    const [
      [user],
      [syncData],
      [sub],
      inventory,
      recipes,
      mealPlans,
      shoppingList,
      cookware,
      wasteLogs,
      consumedLogs,
      customLocs,
      syncKVRows,
      userReferrals,
      cancellations,
      conversions,
      userFeedback,
      corrections,
      appliances,
      providers,
      sessions,
      userNotifications,
      resetTokens,
    ] = await Promise.all([
      db.select().from(users).where(eq(users.id, userId)).limit(1),
      db.select().from(userSyncData).where(eq(userSyncData.userId, userId)).limit(1),
      db.select().from(subscriptions).where(eq(subscriptions.userId, userId)).limit(1),
      db.select().from(userInventoryItems).where(eq(userInventoryItems.userId, userId)),
      db.select().from(userSavedRecipes).where(eq(userSavedRecipes.userId, userId)),
      db.select().from(userMealPlans).where(eq(userMealPlans.userId, userId)),
      db.select().from(userShoppingItems).where(eq(userShoppingItems.userId, userId)),
      db.select().from(userCookwareItems).where(eq(userCookwareItems.userId, userId)),
      db.select().from(userWasteLogs).where(eq(userWasteLogs.userId, userId)),
      db.select().from(userConsumedLogs).where(eq(userConsumedLogs.userId, userId)),
      db.select().from(userStorageLocations).where(eq(userStorageLocations.userId, userId)),
      db.select().from(userSyncKV).where(eq(userSyncKV.userId, userId)),
      db.select().from(referrals).where(eq(referrals.referrerId, userId)),
      db.select().from(cancellationReasons).where(eq(cancellationReasons.userId, userId)),
      db.select().from(conversionEvents).where(eq(conversionEvents.userId, userId)),
      db.select().from(feedback).where(eq(feedback.userId, userId)),
      db.select().from(nutritionCorrections).where(eq(nutritionCorrections.userId, userId)),
      db.select().from(userAppliances).where(eq(userAppliances.userId, userId)),
      db.select().from(authProviders).where(eq(authProviders.userId, userId)),
      db.select().from(userSessions).where(eq(userSessions.userId, userId)),
      db.select().from(notifications).where(eq(notifications.userId, userId)),
      db.select().from(passwordResetTokens).where(eq(passwordResetTokens.userId, userId)),
    ]);

    if (!user) {
      throw AppError.notFound("User not found", "USER_NOT_FOUND");
    }

    const exportData = {
      exportDate: new Date().toISOString(),
      dataSubject: "GDPR Article 20 - Right to Data Portability",
      profile: {
        id: user.id,
        email: user.email,
        displayName: user.displayName,
        profileImageUrl: user.profileImageUrl,
        createdAt: user.createdAt,
        updatedAt: user.updatedAt,
        dietaryRestrictions: user.dietaryRestrictions,
        allergens: user.allergens,
        cookingSkillLevel: user.cookingSkillLevel,
        householdSize: user.householdSize,
        favoriteCategories: user.favoriteCategories,
        expirationAlertDays: user.expirationAlertDays,
        storageAreasEnabled: user.storageAreasEnabled,
        dailyMeals: user.dailyMeals,
        preferredUnits: user.preferredUnits,
        foodsToAvoid: user.foodsToAvoid,
        hasCompletedOnboarding: user.hasCompletedOnboarding,
        notificationsEnabled: user.notificationsEnabled,
        notifyExpiringFood: user.notifyExpiringFood,
        notifyRecipeSuggestions: user.notifyRecipeSuggestions,
        notifyMealReminders: user.notifyMealReminders,
        notificationTime: user.notificationTime,
        isAdmin: user.isAdmin,
        primaryProvider: user.primaryProvider,
        subscriptionTier: user.subscriptionTier,
        subscriptionStatus: user.subscriptionStatus,
        aiRecipesGeneratedThisMonth: user.aiRecipesGeneratedThisMonth,
        aiRecipesResetDate: user.aiRecipesResetDate,
        preRegistrationSource: user.preRegistrationSource,
        preRegisteredAt: user.preRegisteredAt,
        privacyConsentedAt: user.privacyConsentedAt,
        isActivated: user.isActivated,
        referralCode: user.referralCode,
        referredBy: user.referredBy,
        aiRecipeBonusCredits: user.aiRecipeBonusCredits,
      },
      authProviders: providers.map((p) => ({
        provider: p.provider,
        providerId: p.providerId,
        providerEmail: p.providerEmail,
        isPrimary: p.isPrimary,
        createdAt: p.createdAt,
        updatedAt: p.updatedAt,
      })),
      sessions: sessions.map((s) => ({
        userAgent: s.userAgent,
        ipAddress: s.ipAddress,
        expiresAt: s.expiresAt,
        createdAt: s.createdAt,
      })),
      subscription: sub
        ? {
            planType: sub.planType,
            status: sub.status,
            stripePriceId: sub.stripePriceId,
            currentPeriodStart: sub.currentPeriodStart,
            currentPeriodEnd: sub.currentPeriodEnd,
            trialStart: sub.trialStart,
            trialEnd: sub.trialEnd,
            cancelAtPeriodEnd: sub.cancelAtPeriodEnd,
            canceledAt: sub.canceledAt,
            paymentFailedAt: sub.paymentFailedAt,
            createdAt: sub.createdAt,
            updatedAt: sub.updatedAt,
          }
        : null,
      syncData: {
        sectionUpdatedAt: syncData?.sectionUpdatedAt ?? null,
        lastSyncedAt: syncData?.lastSyncedAt ?? null,
        updatedAt: syncData?.updatedAt ?? null,
      },
      wasteLog: wasteLogs.map((w) => ({
        id: w.entryId,
        itemName: w.itemName,
        quantity: w.quantity,
        unit: w.unit,
        reason: w.reason,
        date: w.date,
        extraData: w.extraData,
        createdAt: w.createdAt,
      })),
      consumedLog: consumedLogs.map((c) => ({
        id: c.entryId,
        itemName: c.itemName,
        quantity: c.quantity,
        unit: c.unit,
        date: c.date,
        extraData: c.extraData,
        createdAt: c.createdAt,
      })),
      customLocations: customLocs.map((cl) => ({
        id: cl.locationId,
        name: cl.name,
        type: cl.type,
        extraData: cl.extraData,
        createdAt: cl.createdAt,
        updatedAt: cl.updatedAt,
      })),
      preferences: syncKVRows.find((r) => r.section === "preferences")?.data ?? null,
      analytics: syncKVRows.find((r) => r.section === "analytics")?.data ?? null,
      onboarding: syncKVRows.find((r) => r.section === "onboarding")?.data ?? null,
      userProfile: syncKVRows.find((r) => r.section === "userProfile")?.data ?? null,
      inventory: inventory.map((item) => ({
        id: item.itemId,
        name: item.name,
        barcode: item.barcode,
        quantity: item.quantity,
        unit: item.unit,
        storageLocation: item.storageLocation,
        purchaseDate: item.purchaseDate,
        expirationDate: item.expirationDate,
        category: item.category,
        usdaCategory: item.usdaCategory,
        nutrition: item.nutrition,
        notes: item.notes,
        imageUri: item.imageUri,
        fdcId: item.fdcId,
        addedAt: item.addedAt,
        updatedAt: item.updatedAt,
        deletedAt: item.deletedAt,
      })),
      recipes: recipes.map((r) => ({
        id: r.itemId,
        title: r.title,
        description: r.description,
        ingredients: r.ingredients,
        instructions: r.instructions,
        prepTime: r.prepTime,
        cookTime: r.cookTime,
        servings: r.servings,
        imageUri: r.imageUri,
        cloudImageUri: r.cloudImageUri,
        nutrition: r.nutrition,
        isFavorite: r.isFavorite,
        savedAt: r.savedAt,
        updatedAt: r.updatedAt,
        extraData: r.extraData,
      })),
      mealPlans: mealPlans.map((mp) => ({
        id: mp.itemId,
        date: mp.date,
        meals: mp.meals,
        createdAt: mp.createdAt,
        updatedAt: mp.updatedAt,
        extraData: mp.extraData,
      })),
      shoppingList: shoppingList.map((si) => ({
        id: si.itemId,
        name: si.name,
        quantity: si.quantity,
        unit: si.unit,
        isChecked: si.isChecked,
        category: si.category,
        recipeId: si.recipeId,
        addedAt: si.addedAt,
        updatedAt: si.updatedAt,
        extraData: si.extraData,
      })),
      cookware: cookware.map((c) => ({
        id: c.itemId,
        name: c.name,
        category: c.category,
        alternatives: c.alternatives,
        addedAt: c.addedAt,
        updatedAt: c.updatedAt,
        extraData: c.extraData,
      })),
      referrals: userReferrals.map((r) => ({
        id: r.id,
        referredUserId: r.referredUserId,
        codeUsed: r.codeUsed,
        status: r.status,
        bonusGranted: r.bonusGranted,
        createdAt: r.createdAt,
      })),
      cancellationReasons: cancellations.map((c) => ({
        id: c.id,
        reason: c.reason,
        details: c.details,
        offerShown: c.offerShown,
        offerAccepted: c.offerAccepted,
        createdAt: c.createdAt,
      })),
      conversionEvents: conversions.map((e) => ({
        id: e.id,
        fromTier: e.fromTier,
        toTier: e.toTier,
        source: e.source,
        stripeSessionId: e.stripeSessionId,
        createdAt: e.createdAt,
      })),
      feedback: userFeedback.map((f) => ({
        id: f.id,
        type: f.type,
        category: f.category,
        message: f.message,
        userEmail: f.userEmail,
        deviceInfo: f.deviceInfo,
        screenContext: f.screenContext,
        stepsToReproduce: f.stepsToReproduce,
        severity: f.severity,
        status: f.status,
        adminNotes: f.adminNotes,
        priority: f.priority,
        resolvedAt: f.resolvedAt,
        createdAt: f.createdAt,
        updatedAt: f.updatedAt,
      })),
      nutritionCorrections: corrections.map((nc) => ({
        id: nc.id,
        productName: nc.productName,
        barcode: nc.barcode,
        brand: nc.brand,
        originalSource: nc.originalSource,
        originalSourceId: nc.originalSourceId,
        originalNutrition: nc.originalNutrition,
        correctedNutrition: nc.correctedNutrition,
        imageUrl: nc.imageUrl,
        notes: nc.notes,
        status: nc.status,
        reviewNotes: nc.reviewNotes,
        reviewedAt: nc.reviewedAt,
        createdAt: nc.createdAt,
        updatedAt: nc.updatedAt,
      })),
      userAppliances: appliances.map((a) => ({
        id: a.id,
        applianceId: a.applianceId,
        notes: a.notes,
        brand: a.brand,
        createdAt: a.createdAt,
        updatedAt: a.updatedAt,
      })),
      notifications: userNotifications.map((n) => ({
        id: n.id,
        type: n.type,
        title: n.title,
        body: n.body,
        data: n.data,
        deepLink: n.deepLink,
        isRead: n.isRead,
        createdAt: n.createdAt,
      })),
      passwordResetTokens: resetTokens.map((t) => ({
        id: t.id,
        expiresAt: t.expiresAt,
        createdAt: t.createdAt,
      })),
    };

    res.setHeader("Content-Type", "application/json");
    res.setHeader(
      "Content-Disposition",
      `attachment; filename="chefspaice-data-${userId}.json"`,
    );
    res.json(successResponse(exportData));
  } catch (error) {
    next(error);
  }
});

export default router;
