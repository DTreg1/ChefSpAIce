# ChefSpAIce — Improvement Guide

Step-by-step instructions with ready-to-use prompts for improving each scorecard category. Copy any prompt below and paste it to get started.

---

## 1. UI/UX Design (9/10 → 10/10)

### Step 1: Break up LandingScreen into smaller components

The landing page is currently ~2,500 lines in a single file. Splitting it into focused components improves maintainability and load performance.

**Prompt:**

```
Refactor client/screens/LandingScreen.tsx (currently ~2,500 lines) into smaller, focused components. Extract each major section into its own component file inside client/components/landing/:

- HeroSection.tsx — The hero banner with logo, headline, and CTA buttons
- FeatureGrid.tsx — The feature cards grid section
- HowItWorksSection.tsx — The step-by-step explanation section
- PricingSection.tsx — The pricing/plan comparison section
- FooterSection.tsx — The footer with links, legal, and social

Keep LandingScreen.tsx as the layout coordinator that imports and arranges these sub-components. Preserve all existing functionality, props, theming, animations, and data-testid attributes. Do not change any visual appearance.
```

### Step 2: Replace placeholder App Store URLs

**Prompt:**

```
In client/screens/LandingScreen.tsx, find the placeholder App Store and Play Store URLs (currently containing "id000000000" and placeholder package names). Replace the hardcoded URLs with environment variables so they can be updated without code changes:

1. Add two new environment variables: EXPO_PUBLIC_APP_STORE_URL and EXPO_PUBLIC_PLAY_STORE_URL
2. Update the LandingScreen to read from these env vars with sensible fallbacks
3. Set the env vars to empty strings for now (they'll be filled in when the apps are published)

This way the URLs can be updated from the Secrets tab without redeploying code.
```

### Step 3: Add pull-to-refresh on key screens

**Prompt:**

```
Add pull-to-refresh functionality to the main list screens in the app:

1. InventoryScreen — refresh inventory data
2. RecipesScreen — refresh saved recipes
3. ShoppingListScreen — refresh shopping list
4. MealPlanScreen — refresh meal plans

Use React Native's RefreshControl component inside the existing ScrollView or FlatList on each screen. Connect the refresh action to invalidate the relevant React Query cache and re-trigger the sync. Show the native pull-to-refresh spinner while loading. Match the spinner color to the app's primary theme color.
```

---

## 2. Core Features (10/10)

No changes needed — this is already at full score. Below are optional enhancements if desired.

### Optional: Add recipe sharing

**Prompt:**

```
Add the ability for users to share recipes from the RecipeDetailScreen:

1. Add a share button (use a Share icon from lucide/Feather) in the header
2. When tapped, use React Native's Share API to create a shareable text that includes:
   - Recipe title
   - Ingredient list
   - Step-by-step instructions
   - A "Generated by ChefSpAIce" footer
3. On web, fall back to copying the text to clipboard with a toast notification
4. Include a data-testid="button-share-recipe" on the share button
```

---

## 3. Performance (8/10 → 9/10)

### Step 1: Extract inline chat logic from routes.ts

The main routes file is ~1,500 lines with AI chat, shelf life, and food category logic mixed in. Breaking these out improves maintainability and reduces parse time.

**Prompt:**

```
Refactor server/routes.ts to extract large inline sections into dedicated modules:

1. Move the entire /api/chat endpoint handler (the AI kitchen assistant with function calling, ~200+ lines) into a new file: server/routers/chat.router.ts
2. Move the shelf life estimation logic (schemas, cache, AI suggestion function, and the /api/shelf-life endpoint) into a new file: server/routers/shelf-life.router.ts
3. Move the mapFoodCategory function and the /api/food/search, /api/food/:fdcId, and /api/barcode/:barcode endpoints into a new file: server/routers/food.router.ts
4. Import and mount these routers in routes.ts using app.use()
5. Keep the same route paths, middleware, and authentication requirements
6. Verify all imports are correct and no functionality is lost

The goal is to reduce routes.ts to just route registration (~100 lines) while each feature lives in its own module.
```

### Step 2: Move sync data to JSONB columns

**Prompt:**

```
In shared/schema.ts, the userSyncData table stores inventory, recipes, mealPlans, shoppingList, cookware, wasteLog, consumedLog, and analytics as text columns containing JSON strings. This prevents server-side querying and requires JSON.parse() everywhere.

Create a database migration to convert these columns from text to jsonb:

1. Update the column definitions in shared/schema.ts to use jsonb() instead of text() for: inventory, recipes, mealPlans, shoppingList, preferences, cookware, wasteLog, consumedLog, analytics, onboarding, customLocations, userProfile
2. Generate a Drizzle migration using: npx drizzle-kit generate
3. Update all server code that calls JSON.parse() on these fields to handle the fact that jsonb columns return parsed objects directly
4. Update all server code that calls JSON.stringify() before saving to these fields — jsonb columns accept objects directly
5. Test that sync operations (create, update, delete) still work correctly

Search for all uses of JSON.parse and JSON.stringify related to userSyncData across the server directory to make sure nothing is missed.
```

### Step 3: Add Redis-compatible caching for production readiness

**Prompt:**

```
The server currently uses in-memory Maps for caching shelf life suggestions and AI recipe limits. These caches are lost on server restart and won't work in multi-instance deployments.

Create a simple cache abstraction that can work with either in-memory storage (for development) or an external cache (for production):

1. Create server/lib/cache.ts with a CacheService class that has get(key), set(key, value, ttlMs), delete(key), and clear() methods
2. The default implementation should use an in-memory Map (same as current behavior)
3. Replace the aiSuggestionCache in routes.ts and the aiLimitCache in subscriptionService.ts with instances of the new CacheService
4. Add a comment explaining how to swap to Redis/Upstash in production by implementing the same interface
5. Keep the same TTL values (24 hours for shelf life, 30 seconds for AI limits)
```

---

## 4. Security (9/10 → 10/10)

### Step 1: Add rate limiting to authentication endpoints

**Prompt:**

```
Add rate limiting to protect authentication and AI endpoints from abuse:

1. Install the express-rate-limit package
2. Create a rate limiting middleware in server/middleware/rateLimiter.ts with these configurations:
   - authLimiter: 10 requests per 15 minutes per IP (for /api/auth/login, /api/auth/register)
   - aiLimiter: 30 requests per minute per IP (for /api/chat, /api/suggestions, /api/recipes/generate)
   - generalLimiter: 100 requests per minute per IP (for all other API routes)
3. Apply authLimiter to the login and register routes in server/routes.ts
4. Apply aiLimiter to the AI-heavy routes
5. Apply generalLimiter as a default for all /api/* routes
6. Return proper 429 status with a clear JSON error message: { error: "Too many requests. Please try again later.", retryAfter: <seconds> }
7. Skip rate limiting in test environments (NODE_ENV === "test")
```

### Step 2: Add CSRF protection for cookie-based sessions

**Prompt:**

```
Review the authentication system for CSRF vulnerabilities. The app uses both bearer tokens (for mobile API requests) and HTTP-only cookies (for web session persistence).

1. Check if any routes rely on cookie-based authentication without CSRF protection
2. If cookie-based auth is used for state-changing operations (POST, PUT, DELETE), add CSRF token validation:
   - Install the csrf-csrf package (or csurf alternative)
   - Generate a CSRF token on login and send it to the client
   - Validate the CSRF token on all state-changing requests that use cookie auth
   - Bearer token requests (mobile app) should be exempt since they're not vulnerable to CSRF
3. If no cookie-based auth is used for state-changing operations, document this finding in a code comment on the auth middleware explaining why CSRF is not needed
```

### Step 3: Add request body size limits

**Prompt:**

```
Add explicit request body size limits to protect against oversized payloads:

1. In the Express app setup, ensure express.json() has a size limit: express.json({ limit: '1mb' })
2. For the recipe image upload endpoint, allow a larger limit: express.json({ limit: '10mb' }) applied only to that specific route
3. For the Stripe webhook endpoint, ensure the raw body parser also has an appropriate limit
4. Add a comment explaining why each limit was chosen
```

---

## 5. Error Handling (8/10 → 9/10)

### Step 1: Create a centralized error handling middleware

**Prompt:**

```
Create a centralized Express error handling middleware to standardize all API error responses:

1. Create server/middleware/errorHandler.ts with:
   - An AppError class that extends Error with statusCode, errorCode, and isOperational properties
   - A global error handler middleware function that catches all errors
   - For known AppError instances: return the structured error response
   - For unknown errors: log the full stack trace, return a generic 500 with a request ID for debugging
   - In development: include the error message in the response
   - In production: return only "Internal server error" with a request ID
2. Add a request ID to each request using a simple UUID (add middleware that sets req.id)
3. Register the error handler as the last middleware in server/routes.ts
4. Update 3-5 existing route handlers to use the new AppError class instead of manual res.status().json() calls as examples of the pattern
```

### Step 2: Add structured logging

**Prompt:**

```
Replace ad-hoc console.log/console.error calls with a structured logger:

1. Create server/lib/logger.ts that wraps console methods with:
   - Consistent JSON format: { timestamp, level, message, context, requestId }
   - Log levels: debug, info, warn, error
   - A context parameter for adding metadata (userId, route, duration)
   - In development: pretty-print with colors
   - In production: output JSON for log aggregation
2. Update the authentication middleware (server/middleware/auth.ts) to use the new logger
3. Update the subscription middleware (server/middleware/requireSubscription.ts) to use the new logger
4. Update the Stripe webhook handlers (server/stripe/webhookHandlers.ts) to use the new logger
5. Keep the existing client/lib/logger.ts unchanged — this new logger is server-side only
```

### Step 3: Add error tracking for sync failures

**Prompt:**

```
Improve error visibility for sync failures so issues can be diagnosed:

1. In server/routers/sync.router.ts, add detailed error logging for each sync operation type (inventory, recipes, mealPlans, shoppingList, cookware)
2. Log the operation type, user ID, data size, and specific error message (but not the full data payload for privacy)
3. Add a GET /api/sync/status endpoint (behind requireAuth) that returns:
   - Last successful sync timestamp
   - Number of failed operations in the last 24 hours
   - Whether the user's data is currently consistent
4. On the client side, in client/lib/sync-manager.ts, add logic to surface persistent sync failures to the user after 3 consecutive failures on the same item (show a toast or notification)
```

---

## 6. Accessibility (6/10 → 8/10)

This is the area with the most room for improvement. Only ~24% of UI files currently have accessibility attributes.

### Step 1: Add accessibility labels to all screen headers and navigation

**Prompt:**

```
Add accessibility attributes to the core navigation and header components:

1. In client/components/ExpoGlassHeader.tsx:
   - Add accessibilityRole="header" to the title text
   - Add accessibilityLabel to the search button, back button, and menu button (e.g., "Search inventory", "Go back", "Open menu")
   - Add accessibilityHint to the search input describing its purpose

2. In client/components/CustomTabBar.tsx:
   - Add accessibilityRole="tabBar" to the tab bar container
   - Add accessibilityRole="tab" to each tab button
   - Add accessibilityState={{ selected: true/false }} to indicate the active tab
   - Add accessibilityLabel to each tab (e.g., "Inventory tab", "Recipes tab")

3. In client/components/DrawerContent.tsx:
   - Add accessibilityRole="menu" to the drawer container
   - Add accessibilityRole="menuitem" to each drawer item
   - Add accessibilityLabel to each menu item describing its action

4. In client/components/HamburgerButton.tsx:
   - Add accessibilityLabel="Open navigation menu"
   - Add accessibilityRole="button"
```

### Step 2: Add accessibility labels to all interactive elements on major screens

**Prompt:**

```
Add accessibility attributes to all interactive elements on the 5 most-used screens. For each screen, add accessibilityLabel, accessibilityRole, and accessibilityHint where appropriate:

1. client/screens/InventoryScreen.tsx:
   - All filter/sort buttons
   - Each inventory item row (make it a tappable accessible element with item name and expiry)
   - The add item button
   - Search input

2. client/screens/RecipesScreen.tsx:
   - Recipe cards (include recipe title in the label)
   - Generate recipe button
   - Filter buttons
   - Favorite toggle buttons

3. client/screens/ShoppingListScreen.tsx:
   - Each shopping list item checkbox
   - Add item input and button
   - Clear completed button
   - Order from Instacart button

4. client/screens/MealPlanScreen.tsx:
   - Day selector buttons
   - Meal slot tap targets
   - Add meal buttons

5. client/screens/RecipeDetailScreen.tsx:
   - Servings adjuster (plus/minus buttons)
   - Favorite/unfavorite toggle
   - Share button
   - Cook mode button
   - Each ingredient row
   - Each instruction step

Use descriptive labels that tell screen reader users what the element does, not what it looks like. For example: "Add 1 banana to shopping list" not "Plus button".
```

### Step 3: Add accessibility to modals and overlays

**Prompt:**

```
Add accessibility support to all modal and overlay components:

1. client/components/ChatModal.tsx:
   - Add accessibilityViewIsModal={true} to the modal container
   - Add accessibilityLabel to the close button, send button, and text input
   - Announce new messages with accessibilityLiveRegion="polite" on the message list

2. client/components/RecipeSettingsModal.tsx:
   - Add accessibilityViewIsModal={true}
   - Label all form controls (servings, cuisine, dietary restrictions)

3. client/components/IngredientSwapModal.tsx:
   - Add accessibilityViewIsModal={true}
   - Label the original ingredient and each swap suggestion

4. client/components/NutritionCorrectionModal.tsx:
   - Add accessibilityViewIsModal={true}
   - Label all nutrition value inputs

5. client/components/AddMenu.tsx:
   - Add accessibilityRole="menu" to the popup
   - Add accessibilityRole="menuitem" to each option

6. client/components/TrialEndedModal.tsx:
   - Add accessibilityViewIsModal={true}
   - Add accessibilityLabel to the upgrade and dismiss buttons

For all modals: ensure focus is trapped inside the modal when open, and returns to the triggering element when closed.
```

### Step 4: Add semantic text roles and dynamic announcements

**Prompt:**

```
Improve screen reader experience with semantic roles and dynamic announcements:

1. In client/components/ExpiryBadge.tsx:
   - Add accessibilityLabel that reads the expiry status aloud (e.g., "Expires in 2 days" or "Expired 1 day ago")
   - Add accessibilityRole="text"

2. In client/components/TrialStatusBadge.tsx:
   - Add accessibilityLabel with trial status (e.g., "Trial: 3 days remaining")

3. In client/components/NutritionScoreBadge.tsx:
   - Add accessibilityLabel with the nutrition score and grade

4. In client/components/OfflineIndicator.tsx:
   - Add accessibilityLiveRegion="assertive" so screen readers announce connectivity changes
   - Add accessibilityLabel="You are currently offline. Changes will sync when connection is restored."

5. In client/components/SyncStatusIndicator.tsx:
   - Add accessibilityLiveRegion="polite" for sync status changes
   - Add descriptive accessibilityLabel for each state (syncing, synced, error)

6. In client/components/UpgradePrompt.tsx:
   - Add accessibilityRole="alert"
   - Add accessibilityLabel describing the upgrade offer
```

---

## 7. Code Quality (9/10 → 10/10)

### Step 1: Remove any types from sync router

**Prompt:**

```
In server/routers/sync.router.ts and server/routers/external-api.router.ts, find and replace all uses of the `any` type with proper TypeScript types:

1. Search for `: any` and `as any` in both files
2. For inventory arrays, use the existing Zod schema types or define proper interfaces
3. For parsed JSON data, use the inferred types from the Zod schemas (z.infer<typeof inventoryItemSchema>, etc.)
4. For catch blocks, use `unknown` and narrow with instanceof Error
5. Make sure all replacements compile without TypeScript errors

Do not change any runtime behavior — this is purely a type safety improvement.
```

### Step 2: Add frontend component tests

**Prompt:**

```
Set up a frontend testing framework and add tests for the most critical client-side logic:

1. Make sure vitest is configured to handle React Native / Expo files (check if there's already a vitest config that covers client code)
2. Create tests for these critical hooks:
   - client/hooks/useTrialStatus.ts — test trial days calculation, expired state, active state
   - client/hooks/useSubscription.tsx — test tier detection, limit checking, feature access
3. Create tests for these utility modules:
   - client/lib/nutrition-score.ts — test score calculation with various nutrition inputs
   - client/lib/shelf-life-data.ts — test shelf life lookup for known foods
4. Place test files next to the source files with .test.ts extension
5. Each test file should have at least 3 test cases covering normal operation, edge cases, and error states
```

### Step 3: Add end-to-end test for the web landing page

**Prompt:**

```
The web landing page (served at the root URL) is the primary public-facing page. Add Playwright end-to-end tests to verify it works correctly:

1. Test that the landing page loads and shows the app name "ChefSpAIce"
2. Test that all navigation links work (About, Privacy, Terms, Support) — clicking each one should show the corresponding page content
3. Test that the pre-registration email form works:
   - Enter a valid email address
   - Submit the form
   - Verify a success message appears
4. Test that the dark/light mode toggle works if present
5. Test that the page is responsive — check layout at both 1280px and 400px widths

Use the run_test tool with these test steps.
```

---

## 8. Mobile (9/10 → 10/10)

### Step 1: Add biometric authentication

**Prompt:**

```
Add optional biometric authentication (Face ID / fingerprint) as a convenience feature for returning users:

1. Install expo-local-authentication
2. Create a new hook client/hooks/useBiometricAuth.ts that:
   - Checks if biometric hardware is available
   - Checks if biometrics are enrolled
   - Provides an authenticate() function that shows the native biometric prompt
   - Stores the user's biometric preference in AsyncStorage
3. In the AuthContext, after loading a stored session token on app launch:
   - If biometric auth is enabled and a stored token exists, prompt for biometric verification
   - On success, proceed with the stored token
   - On failure, show the login screen
4. Add a toggle in SettingsScreen to enable/disable biometric login
   - Only show the toggle if biometric hardware is available
   - Default to disabled
5. Add proper accessibilityLabel to the biometric toggle
```

### Step 2: Add deep linking for recipe sharing

**Prompt:**

```
Add deep linking support so users can share recipe links that open directly in the app:

1. Configure deep linking in the Expo app config for the scheme "chefspaice://"
2. Add URL handling in client/App.tsx to parse incoming deep links
3. Support these deep link patterns:
   - chefspaice://recipe/{recipeId} — opens RecipeDetailScreen for that recipe
   - chefspaice://inventory — opens InventoryScreen
   - chefspaice://scan — opens ScanHubScreen
4. Update the recipe share feature to include the deep link URL alongside the text content
5. If the user opens a deep link but isn't authenticated, save the target destination and redirect after login
```

---

## 9. Data Management (9/10 → 10/10)

### Step 1: Add data backup export/import

**Prompt:**

```
Add the ability for users to export and import a full backup of their data:

1. Create a new endpoint POST /api/sync/export (behind requireAuth) that:
   - Fetches all of the user's sync data (inventory, recipes, meal plans, shopping list, cookware, preferences)
   - Packages it into a single JSON object with a version number and export timestamp
   - Returns it as a downloadable JSON file

2. Create a new endpoint POST /api/sync/import (behind requireAuth) that:
   - Accepts a JSON backup file
   - Validates the format and version
   - Gives the user the choice to merge with or replace existing data
   - Applies subscription limits during import (e.g., Basic users can't import more than 25 pantry items)

3. Add UI in SettingsScreen for:
   - "Export My Data" button that downloads the backup
   - "Import Data" button that opens a file picker and uploads the backup
   - Show a confirmation dialog before importing that explains what will happen
```

### Step 2: Add data deletion (GDPR compliance)

**Prompt:**

```
Add a complete account and data deletion feature for privacy compliance:

1. Create a new endpoint DELETE /api/auth/account (behind requireAuth) that:
   - Requires the user to confirm by sending their email in the request body
   - Deletes all user data: sync data, sessions, auth providers, subscriptions, feedback
   - Deletes recipe images from object storage
   - Cancels any active Stripe subscription
   - Finally deletes the user record itself
   - Returns a confirmation response

2. Add UI in SettingsScreen under a "Danger Zone" section:
   - "Delete My Account" button (red, clearly destructive)
   - Shows a modal explaining what will be deleted
   - Requires typing "DELETE" to confirm
   - Shows a loading spinner while deletion is in progress
   - On success, clears local storage and navigates to the auth screen

3. Add accessibilityLabel="Delete my account permanently" to the delete button
```

---

## 10. Monetization (10/10)

No changes needed — this is already at full score. Below are optional enhancements.

### Optional: Add referral system

**Prompt:**

```
Add a referral system where existing users can invite friends and both get benefits:

1. Add a referralCode field to the users table (unique 8-character alphanumeric code, auto-generated on registration)
2. Add a referredBy field to track who referred each user
3. Create endpoints:
   - GET /api/referral/code — returns the user's referral code and a shareable link
   - POST /api/referral/apply — applies a referral code during registration
4. When a referral is successful (referred user completes registration):
   - Give the referrer 3 extra AI recipe generations for the month
   - Give the new user an extended 14-day trial instead of 7 days
5. Add a "Refer a Friend" section in SettingsScreen that shows the user's referral code and a share button
6. Track referral stats: how many people used the code, how many signed up
```

### Optional: Add usage analytics dashboard for admin

**Prompt:**

```
Create an admin dashboard page that shows key business metrics:

1. Create a new endpoint GET /api/admin/analytics (behind requireAdmin) that returns:
   - Total registered users (all time)
   - New registrations (last 7 days, last 30 days)
   - Active users (users who synced in the last 7 days)
   - Subscription breakdown (how many Basic, Pro, Trial, Expired)
   - Revenue metrics from Stripe (MRR, total subscribers)
   - AI usage (total recipes generated this month)
   - Most common food items in inventories

2. Create a simple web admin page at /admin (protected by admin auth) that displays these metrics in a clean dashboard layout
3. Include basic charts for user growth and subscription distribution
```

---

## Priority Order

If you want to tackle these in order of impact, here's the recommended sequence:

| Priority | Category | Why |
|---|---|---|
| 1 | Accessibility (Steps 1-4) | Largest gap (6/10). Directly affects usability for all users. |
| 2 | Security (Step 1) | Rate limiting is a common attack vector. Quick win. |
| 3 | Performance (Step 1) | Extracting routes.ts improves maintainability immediately. |
| 4 | Error Handling (Step 1) | Centralized errors reduce debugging time for all future work. |
| 5 | Code Quality (Step 1) | Removing `any` types prevents future bugs. Quick fix. |
| 6 | Data Management (Step 2) | GDPR compliance is a legal requirement in many markets. |
| 7 | UI/UX Design (Step 1) | Breaking up LandingScreen is good hygiene. |
| 8 | Mobile (Step 1) | Biometric auth is a nice-to-have, not critical. |
| 9 | Performance (Step 2) | JSONB migration is high-effort, moderate reward. |
| 10 | Data Management (Step 1) | Backup export/import is useful but not urgent. |
