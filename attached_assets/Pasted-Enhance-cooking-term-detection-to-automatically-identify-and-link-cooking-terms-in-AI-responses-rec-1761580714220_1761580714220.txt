Enhance cooking term detection to automatically identify and link cooking terms
in AI responses, recipes, and user content.

REQUIREMENTS:
1. Detect cooking terms in:
- AI chat responses
- Recipe instructions
- User-generated content
- Food descriptions

2. Handle variations:
- Plurals (dice → dicing, diced)
- Verb forms (sauté → sautéed, sautéing)
- Common misspellings
- Regional variations (broil/grill)

3. Context awareness:
- Don't link in glossary page itself
- Avoid false positives
- Prioritize longer terms
- Handle compound terms

IMPLEMENTATION:
1. Create term detection service (server/services/term-detector.service.ts):

interface TermMatch {
term: string;
termId: string;
start: number;
end: number;
definition: string;
}

class CookingTermDetector {
private terms: Map<string, CookingTerm> = new Map();
private patterns: RegExp[] = [];

async initialize() {
// Load all cooking terms from database
const terms = await db.select().from(cookingTerms);

// Build lookup map and regex patterns
for (const term of terms) {
this.terms.set(term.name.toLowerCase(), term);

// Add variations
if (term.variations) {
for (const variation of term.variations) {
this.terms.set(variation.toLowerCase(), term);
}
}

// Create regex pattern for each term
const pattern = this.createPattern(term);
this.patterns.push(pattern);
}

// Sort patterns by length (longest first) to match longer terms first
this.patterns.sort((a, b) => b.source.length - a.source.length);
}

private createPattern(term: CookingTerm): RegExp {
const variations = [term.name, ...(term.variations || [])];
const pattern = variations
.map(v => v.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'))
.join('|');

// Word boundaries to avoid partial matches
return new RegExp(`\\b(${pattern})(?:ing|ed|s)?\\b`, 'gi');
}

detectTerms(text: string): TermMatch[] {
const matches: TermMatch[] = [];
const usedRanges: Array<[number, number]> = [];

for (const pattern of this.patterns) {
let match;
while ((match = pattern.exec(text)) !== null) {
const start = match.index;
const end = start + match[0].length;

// Check if this range overlaps with existing match
const overlaps = usedRanges.some(([s, e]) =>
(start >= s && start < e) || (end > s && end <= e)
);

if (!overlaps) {
const termKey = match[1].toLowerCase();
const term = this.terms.get(termKey);

if (term) {
matches.push({
term: match[0],
termId: term.id,
start,
end,
definition: term.shortDefinition
});
usedRanges.push([start, end]);
}
}
}
}

return matches.sort((a, b) => a.start - b.start);
}

enrichTextWithTerms(text: string): string {
const matches = this.detectTerms(text);
if (matches.length === 0) return text;

let result = '';
let lastIndex = 0;

for (const match of matches) {
// Add text before match
result += text.slice(lastIndex, match.start);

// Add linked term
result += `<span class="cooking-term" data-term-id="${match.termId}" title="${match.definition}">${match.term}</span>`;

lastIndex = match.end;
}

// Add remaining text
result += text.slice(lastIndex);

return result;
}
}

export const termDetector = new CookingTermDetector();

2. Initialize on server startup (server/index.ts):

import { termDetector } from './services/term-detector.service';

async function startServer() {
// Initialize term detector
await termDetector.initialize();
console.log('✓ Cooking term detector initialized');

// Start Express server...
}

3. Add API endpoint for term detection:

router.post('/api/cooking-terms/detect', async (req, res) => {
const { text } = req.body;

if (!text) {
return res.status(400).json({ error: 'Text is required' });
}

const matches = termDetector.detectTerms(text);
res.json({ matches });
});

router.post('/api/cooking-terms/enrich', async (req, res) => {
const { text } = req.body;

if (!text) {
return res.status(400).json({ error: 'Text is required' });
}

const enriched = termDetector.enrichTextWithTerms(text);
res.json({ text: enriched });
});

4. Integrate with AI chat responses:

// In chat message handler
async function processAIResponse(response: string): string {
// Detect and enrich cooking terms
return termDetector.enrichTextWithTerms(response);
}

FRONTEND INTEGRATION:
1. Create CookingTermTooltip component:

const CookingTermTooltip = ({ termId, children }) => {
const { data: term } = useQuery({
queryKey: ['/api/cooking-terms', termId],
});

return (
<Tooltip>
<TooltipTrigger asChild>
<span className="cooking-term-highlight cursor-help underline decoration-dotted">
{children}
</span>
</TooltipTrigger>
<TooltipContent className="max-w-sm">
<div className="space-y-2">
<h4 className="font-semibold">{term?.name}</h4>
<p className="text-sm text-muted-foreground">
{term?.shortDefinition}
</p>
<Link
to={`/glossary#${term?.id}`}
className="text-xs text-primary hover:underline"
>
View full definition →
</Link>
</div>
</TooltipContent>
</Tooltip>
);
};

2. Add term highlighting in recipe display:

const EnrichedRecipeInstructions = ({ instructions }) => {
const { data: enriched } = useQuery({
queryKey: ['/api/cooking-terms/enrich', { text: instructions }],
queryFn: async () => {
const res = await apiRequest('POST', '/api/cooking-terms/enrich', {
text: instructions
});
return res.text;
}
});

return (
<div
dangerouslySetInnerHTML={{ __html: enriched }}
className="enriched-content"
/>
);
};

3. Add CSS for term highlighting:

.cooking-term-highlight {
color: hsl(var(--primary));
text-decoration: underline;
text-decoration-style: dotted;
text-underline-offset: 2px;
cursor: help;
}

.cooking-term-highlight:hover {
text-decoration-style: solid;
background: hsl(var(--primary) / 0.1);
padding: 0 2px;
border-radius: 2px;
}

OPTIMIZATION:
1. Cache term patterns:
- Build patterns once on startup
- Store in memory for fast lookup
- Rebuild when terms are added/updated

2. Lazy loading for tooltips:
- Only load full definition on hover
- Preload common terms
- Cache loaded definitions

3. Performance considerations:
- Limit text length for detection (max 10,000 chars)
- Batch processing for long content
- Debounce detection in live editors

ADMIN FEATURES:
1. Term variation management:
- Add common variations to existing terms
- Auto-suggest variations based on usage
- Bulk import variations

2. Detection analytics:
- Track which terms are most detected
- Identify terms that need variations added
- Monitor false positives

3. Manual overrides:
- Exclude certain contexts
- Add custom term boundaries
- Configure detection sensitivity

TESTING:
- Test with various text lengths
- Verify no false positives
- Test overlapping term detection
- Check performance with large texts
- Validate tooltip interactions
- Test term variation detection
