/**
 * Image Processing & Management Domain
 * 
 * Tables for image processing, OCR, alt text generation, and quality assessments.
 * Used for accessibility features and content analysis.
 */

import { pgTable, text, varchar, integer, timestamp, boolean, index, jsonb, serial, real } from "drizzle-orm/pg-core";
import { createInsertSchema } from "drizzle-zod";
import { z } from "zod";
import { sql } from "drizzle-orm";
import { users } from "./auth";

/**
 * Image Metadata Table
 * 
 * Stores metadata and analysis results for uploaded images.
 */
export const imageMetadata = pgTable("image_metadata", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  userId: varchar("user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
  
  // Image info
  url: text("url").notNull(),
  thumbnailUrl: text("thumbnail_url"),
  filename: text("filename").notNull(),
  mimeType: text("mime_type").notNull(),
  size: integer("size").notNull(),
  width: integer("width"),
  height: integer("height"),
  
  // Analysis
  altText: text("alt_text"),
  autoGeneratedAlt: text("auto_generated_alt"),
  detectedText: text("detected_text"),
  
  // Categorization
  category: text("category"),
  tags: text("tags").array(),
  
  // Metadata
  metadata: jsonb("metadata").$type<{
    exif?: Record<string, any>;
    colors?: string[];
    faces?: number;
    objects?: string[];
    scene?: string;
  }>(),
  
  createdAt: timestamp("created_at").defaultNow(),
  updatedAt: timestamp("updated_at").defaultNow(),
}, (table) => [
  index("image_metadata_user_id_idx").on(table.userId),
  index("image_metadata_category_idx").on(table.category),
  index("image_metadata_created_at_idx").on(table.createdAt),
]);

/**
 * Alt Text Quality Table
 * 
 * Tracks quality scores for image alt text to improve accessibility.
 */
export const altTextQuality = pgTable("alt_text_quality", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  imageId: varchar("image_id").notNull().unique().references(() => imageMetadata.id, { onDelete: "cascade" }),
  
  // Overall scores
  qualityScore: integer("quality_score").notNull().default(0),
  accessibilityScore: integer("accessibility_score").notNull().default(0),
  
  // Quality metrics (0-100 each)
  lengthScore: integer("length_score"),
  descriptiveScore: integer("descriptive_score"),
  contextScore: integer("context_score"),
  keywordScore: integer("keyword_score"),
  
  // Accessibility metrics
  screenReaderScore: integer("screen_reader_score"),
  wcagCompliance: boolean("wcag_compliance").default(false),
  
  // Issues
  issues: text("issues").array(),
  suggestions: text("suggestions").array(),
  
  // Review status
  reviewed: boolean("reviewed").default(false),
  reviewedAt: timestamp("reviewed_at"),
  reviewedBy: varchar("reviewed_by"),
  
  createdAt: timestamp("created_at").defaultNow(),
  updatedAt: timestamp("updated_at").defaultNow(),
}, (table) => [
  index("alt_text_quality_score_idx").on(table.qualityScore),
  index("alt_text_quality_reviewed_idx").on(table.reviewed),
]);

/**
 * Image Processing Queue Table
 * 
 * Manages image processing tasks like resizing, optimization, and analysis.
 */
export const imageProcessing = pgTable("image_processing", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  userId: varchar("user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
  imageId: varchar("image_id").references(() => imageMetadata.id, { onDelete: "cascade" }),
  
  // Processing details
  operation: text("operation").notNull(),
  params: jsonb("params").$type<{
    width?: number;
    height?: number;
    quality?: number;
    format?: string;
    [key: string]: any;
  }>(),
  
  // Status
  status: text("status").notNull().default('pending'),
  priority: integer("priority").default(0),
  
  // Results
  resultUrl: text("result_url"),
  error: text("error"),
  metadata: jsonb("metadata").$type<Record<string, any>>(),
  
  // Timing
  startedAt: timestamp("started_at"),
  completedAt: timestamp("completed_at"),
  createdAt: timestamp("created_at").defaultNow(),
}, (table) => [
  index("image_processing_user_id_idx").on(table.userId),
  index("image_processing_status_idx").on(table.status),
  index("image_processing_priority_idx").on(table.priority),
]);

/**
 * Image Processing Jobs Table
 * 
 * Tracks individual image processing operations with progress and status.
 * Supports resize, compress, thumbnail, watermark, and optimize operations.
 */
export const imageProcessingJobs = pgTable("image_processing_jobs", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  userId: text("user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
  imageUrl: text("image_url").notNull(),
  outputUrl: text("output_url"),
  operation: text("operation").notNull(), // resize, compress, thumbnail, watermark, optimize
  presetId: text("preset_id"),
  parameters: jsonb("parameters").$type<{
    width?: number;
    height?: number;
    quality?: number;
    format?: string;
    watermarkText?: string;
    watermarkPosition?: string;
    thumbnailSize?: number;
    [key: string]: any;
  }>(),
  status: text("status").notNull().default("pending"), // pending, processing, completed, failed
  error: text("error"),
  progress: integer("progress").notNull().default(0), // 0-100
  startedAt: timestamp("started_at"),
  completedAt: timestamp("completed_at"),
  createdAt: timestamp("created_at").defaultNow(),
}, (table) => [
  index("image_processing_jobs_user_id_idx").on(table.userId),
  index("image_processing_jobs_status_idx").on(table.status),
  index("image_processing_jobs_created_at_idx").on(table.createdAt),
]);

/**
 * Image Presets Table
 * 
 * Stores reusable image processing presets with operation chains.
 */
export const imagePresets = pgTable("image_presets", {
  id: serial("id").primaryKey(),
  userId: varchar("user_id").references(() => users.id, { onDelete: "cascade" }),
  name: text("name").notNull(),
  description: text("description"),
  operations: jsonb("operations").$type<Array<{
    type: string;
    params: Record<string, any>;
  }>>().notNull().default([]),
  settings: jsonb("settings").$type<{
    width?: number;
    height?: number;
    quality?: number;
    format?: string;
  }>(),
  isDefault: boolean("is_default").notNull().default(false),
  isPublic: boolean("is_public").default(false),
  usageCount: integer("usage_count").default(0),
  createdBy: text("created_by"),
  createdAt: timestamp("created_at").defaultNow(),
  updatedAt: timestamp("updated_at").defaultNow(),
}, (table) => [
  index("image_presets_user_id_idx").on(table.userId),
  index("image_presets_is_public_idx").on(table.isPublic),
  index("image_presets_is_default_idx").on(table.isDefault),
]);

/**
 * OCR Results Table
 * 
 * Stores optical character recognition results from images.
 */
export const ocrResults = pgTable("ocr_results", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  userId: varchar("user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
  imageId: varchar("image_id").notNull().references(() => imageMetadata.id, { onDelete: "cascade" }),
  
  // OCR results
  text: text("text").notNull(),
  confidence: real("confidence").notNull(),
  language: text("language"),
  
  // Structured data
  structuredData: jsonb("structured_data").$type<{
    blocks?: Array<{
      text: string;
      confidence: number;
      bbox: [number, number, number, number];
    }>;
    lines?: string[];
    words?: string[];
  }>(),
  
  // Processing info
  engine: text("engine").notNull().default('tesseract'),
  processingTime: integer("processing_time"),
  
  // Review status
  reviewed: boolean("reviewed").default(false),
  corrected: boolean("corrected").default(false),
  
  createdAt: timestamp("created_at").defaultNow(),
  updatedAt: timestamp("updated_at").defaultNow(),
}, (table) => [
  index("ocr_results_user_id_idx").on(table.userId),
  index("ocr_results_image_id_idx").on(table.imageId),
  index("ocr_results_confidence_idx").on(table.confidence),
]);

/**
 * OCR Corrections Table
 * 
 * Tracks manual corrections to OCR results for training and improvement.
 */
export const ocrCorrections = pgTable("ocr_corrections", {
  id: serial("id").primaryKey(),
  ocrResultId: varchar("ocr_result_id").notNull().references(() => ocrResults.id, { onDelete: "cascade" }),
  userId: varchar("user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
  
  // Correction details
  originalText: text("original_text").notNull(),
  correctedText: text("corrected_text").notNull(),
  
  // Context
  context: text("context"),
  reason: text("reason"),
  
  // Validation
  validated: boolean("validated").default(false),
  validatedBy: varchar("validated_by"),
  
  createdAt: timestamp("created_at").defaultNow(),
}, (table) => [
  index("ocr_corrections_ocr_result_id_idx").on(table.ocrResultId),
  index("ocr_corrections_user_id_idx").on(table.userId),
]);

/**
 * Face Detections Table
 * 
 * Stores face detection results from TensorFlow.js BlazeFace model.
 * Tracks detected faces and their coordinates for privacy features and avatar cropping.
 */
export const faceDetections = pgTable("face_detections", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  userId: varchar("user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
  imageId: varchar("image_id").notNull(),
  imageUrl: text("image_url").notNull(),
  facesDetected: integer("faces_detected").notNull().default(0),
  faceCoordinates: jsonb("face_coordinates").$type<Array<{
    x: number;
    y: number;
    width: number;
    height: number;
    confidence: number;
    landmarks?: {
      leftEye?: { x: number; y: number };
      rightEye?: { x: number; y: number };
      nose?: { x: number; y: number };
      mouth?: { x: number; y: number };
      leftEar?: { x: number; y: number };
      rightEar?: { x: number; y: number };
    };
  }>>().notNull().default([]),
  processedImageUrl: text("processed_image_url"),
  processingType: text("processing_type"),
  metadata: jsonb("metadata").$type<{
    modelVersion?: string;
    processingTime?: number;
    originalDimensions?: { width: number; height: number };
    blurIntensity?: number;
    cropSettings?: { aspectRatio?: string; padding?: number };
  }>(),
  createdAt: timestamp("created_at").defaultNow(),
  updatedAt: timestamp("updated_at").defaultNow(),
}, (table) => [
  index("face_detections_user_id_idx").on(table.userId),
  index("face_detections_image_id_idx").on(table.imageId),
  index("face_detections_created_at_idx").on(table.createdAt),
]);


// ==================== Type Definitions ====================

// Image Metadata
export const insertImageMetadataSchema = createInsertSchema(imageMetadata);

export type InsertImageMetadata = z.infer<typeof insertImageMetadataSchema>;
export type ImageMetadata = typeof imageMetadata.$inferSelect;

// Alt Text Quality
export const insertAltTextQualitySchema = createInsertSchema(altTextQuality);

export type InsertAltTextQuality = z.infer<typeof insertAltTextQualitySchema>;
export type AltTextQuality = typeof altTextQuality.$inferSelect;

// Image Processing
export const imageProcessingStatusSchema = z.enum(['pending', 'processing', 'completed', 'failed', 'cancelled']);

export const insertImageProcessingSchema = createInsertSchema(imageProcessing)
  .extend({
    status: imageProcessingStatusSchema,
  });

export type InsertImageProcessing = z.infer<typeof insertImageProcessingSchema>;
export type ImageProcessing = typeof imageProcessing.$inferSelect;

// Image Processing Jobs
export const imageProcessingJobOperationSchema = z.enum(['resize', 'compress', 'thumbnail', 'watermark', 'optimize']);
export const imageProcessingJobStatusSchema = z.enum(['pending', 'processing', 'completed', 'failed']);

export const insertImageProcessingJobSchema = createInsertSchema(imageProcessingJobs)
  .omit({ id: true, createdAt: true })
  .extend({
    operation: imageProcessingJobOperationSchema,
    status: imageProcessingJobStatusSchema.default('pending'),
    progress: z.number().min(0).max(100).default(0),
  });

export type InsertImageProcessingJob = z.infer<typeof insertImageProcessingJobSchema>;
export type ImageProcessingJob = typeof imageProcessingJobs.$inferSelect;

// Image Presets
export const insertImagePresetSchema = createInsertSchema(imagePresets)
  .omit({ id: true, createdAt: true, updatedAt: true });

export type InsertImagePreset = z.infer<typeof insertImagePresetSchema>;
export type ImagePreset = typeof imagePresets.$inferSelect;

// OCR Results
export const ocrEngineSchema = z.enum(['tesseract', 'google-vision', 'aws-textract', 'azure-ocr']);

export const insertOcrResultSchema = createInsertSchema(ocrResults)
  .extend({
    engine: ocrEngineSchema,
  });

export type InsertOcrResult = z.infer<typeof insertOcrResultSchema>;
export type OcrResult = typeof ocrResults.$inferSelect;

// OCR Corrections
export const insertOcrCorrectionSchema = createInsertSchema(ocrCorrections);

export type InsertOcrCorrection = z.infer<typeof insertOcrCorrectionSchema>;
export type OcrCorrection = typeof ocrCorrections.$inferSelect;

// Face Detections
export const insertFaceDetectionSchema = createInsertSchema(faceDetections);

export type InsertFaceDetection = z.infer<typeof insertFaceDetectionSchema>;
export type FaceDetection = typeof faceDetections.$inferSelect;